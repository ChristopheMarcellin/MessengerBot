// bon dernier backup 2025-05-08 1h48 am

// === Load env + dependencies ===
require('dotenv').config();
const express = require('express');
const app = express();
app.use(express.json());

const axios = require('axios');
const { getNextUnansweredSpec, updateSpecFromInput, buildSpecSummary, getPromptForSpec, isValidAnswer } = require('./modules/specEngine');
const { setProjectType, initializeSpecFields } = require('./modules/utils');
const { sendMessage } = require('./modules/messenger');
const {
    stepInitializeSession,
    stepHandleProjectType,
    stepAskNextSpec,
    stepSummarizeIfComplete,
    stepCheckEndSession,
    stepFallback
} = require('./modules/steps');
const { getSession, setSession, deleteSession } = require('./modules/sessionStore');

// index.js – Corrected version with all required steps active up to stepHandleSpecAnswer
require('dotenv').config();
const express = require('express');
const axios = require('axios');
const app = express();
app.use(express.json());

const { sendMessage } = require('./modules/messenger');
const { getSession, setSession, clearSession } = require('./modules/sessionStore');
const { setProjectType, initializeSpecFields } = require('./modules/utils');
const { runDirector } = require('./modules/director');

/*
const {
    getNextUnansweredSpec,
    shouldAskNextSpec,
    updateSpecFromInput,
    buildSpecSummary,
    resetInvalidSpecs,
    getPromptForSpec,
} = require('./modules/specEngine');
*/

const VERIFY_TOKEN = process.env.VERIFY_TOKEN;
const PAGE_ACCESS_TOKEN = process.env.PAGE_ACCESS_TOKEN;

app.get('/', (req, res) => res.send('Bot server is running.'));

app.get('/webhook', (req, res) => {
    const mode = req.query['hub.mode'];
    const token = req.query['hub.verify_token'];
    const challenge = req.query['hub.challenge'];

    if (mode === 'subscribe' && token === VERIFY_TOKEN) {
        console.log('[VERIFY] Webhook verified');
        res.status(200).send(challenge);
    } else {
        res.sendStatus(403);
    }
});

// === Webhook ===
app.post('/webhook', async (req, res) => {
    try {
        const messagingEvent = req.body.entry?.[0]?.messaging?.[0];

        if (!messagingEvent) return res.sendStatus(200);
        if (messagingEvent.message?.is_echo) {
            console.log(`[ECHO] Skipping bot echo: "${messagingEvent.message.text}"`);
            return res.sendStatus(200);
        }
        if (messagingEvent.delivery || messagingEvent.read) return res.sendStatus(200);

        const senderId = messagingEvent.sender?.id;
        const receivedMessage = messagingEvent.message?.text?.trim();
        if (!receivedMessage || !senderId) return res.sendStatus(200);

        // 🔐 Toujours initialiser une session AVANT tout filtrage
        let session = getSession(senderId);
        if (!session) {
            session = {};
            setSession(senderId, session);
        }

        // 🔒 Blocage strict : si message déjà reçu → ignorer
        if (session.lastUserMessage === receivedMessage) {
            console.log(`[HARD BLOCK] Répétition bloquée de "${receivedMessage}"`);
            return res.sendStatus(200);
        }

        // 🧠 Stockage immédiat du message reçu
        session.lastUserMessage = receivedMessage;

        const cleanText = receivedMessage.toLowerCase().replace(/[^\w\s]/gi, '').trim();
        console.log(`[RECEIVED] From: ${senderId} | Message: "${receivedMessage}"`);

        const context = {
            senderId,
            message: receivedMessage,
            session,
            cleanText,
            greetings: ["bonjour", "salut", "hello", "hi", "comment ca va"],
            res
        };

        context.message = receivedMessage; // Sécurité : pas d'ambiguïté
        console.log(`[DEBUG] Message transmis au directeur: "${context.message}"`);

        const triggered = await runDirector(context);
        if (triggered) {
            console.log('[INDEX] Le directeur a détecté un scénario actif.');
        } else {
            console.log('[INDEX] Aucun scénario détecté par le directeur.');
        }

    } catch (error) {
        console.error("[ERROR]", error);
        res.status(500).send('Server Error');
    }
});

/*
// === Optionnel : séquence de steps (désactivée actuellement)
async function launchSteps(context) {
    const steps = [
        stepCheckEndSession,
        stepInitializeSession,
        stepHandleUserQuestions,
        stepHandleProjectType,
        stepHandleSpecAnswer,
        // stepAskNextSpec,
        // stepConfirmSummary,
        // stepCollectContact,
        // stepSignoff,
    ];

    for (const step of steps) {
        console.log(`[STEP] Starting ${step.name}()`);
        const proceed = await step(context);
        if (!proceed) break;
    }
}
*/

// === Start Server ===
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`[INIT] Server running on port ${PORT}`));


// === Logger ===
function logSessionState(senderId, session) {
    if (!session) return;
    console.log(`[STATE] Session ${senderId}`);
    console.log(` - projectType: ${session.specValues?.projectType}`);
    console.log(` - currentSpec: ${session.currentSpec || "(none)"}`);
    console.log(` - specValues:`, JSON.stringify(session.specValues, null, 2));
}

// === Main Launch Sequence ===


async function launchSteps({ senderId, message }) {
    logSessionState(senderId); // Facultatif pour debug

    if (!stepCheckEndSession({ senderId, message })) return;
    if (!await stepInitializeSession({ senderId, message })) return;
    if (!stepHandleProjectType({ senderId, message })) return;
    if (!stepHandleSpecAnswer({ senderId, message })) return;
    if (!stepAskNextSpec({ senderId })) return;
    if (!stepSummarizeAndConfirm({ senderId, message })) return;
    if (!stepCollectContact({ senderId, message })) return;
    if (!stepHandleFallback({ senderId, message })) return;
}

// === Start Server ===
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`[INIT] Server running on port ${PORT}`));
